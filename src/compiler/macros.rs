#[macro_export]
macro_rules! generate_file_header {
    ($file:expr) => {
        writeln!($file, "// Generated by VibeLang Rust Compiler")?;
        writeln!(
            $file,
            "// Implements Meaning Typed Prompting (MTP) Protocol"
        )?;
        writeln!($file)?;
    };
}

/// Generates standard imports needed for VibeLang runtime
#[macro_export]
macro_rules! generate_imports {
    ($file:expr) => {
        writeln!($file, "use std::collections::HashMap;")?;
        writeln!($file, "use serde_json::json;")?;
        writeln!($file)?;
    };
}

/// Generates the VibeValue enum with all its variants
#[macro_export]
macro_rules! generate_vibe_value_enum {
    ($file:expr) => {
        writeln!($file, "#[derive(Debug, Clone)]")?;
        writeln!($file, "pub enum VibeValue {{")?;
        writeln!($file, "    Null,")?;
        writeln!($file, "    Boolean(bool),")?;
        writeln!($file, "    Number(f64),")?;
        writeln!($file, "    String(String),")?;
        writeln!($file, "}}")?;
        writeln!($file)?;
    };
}

/// Generates the parametric vibe_execute_prompt function
#[macro_export]
macro_rules! generate_parametric_vibe_execute_prompt {
    ($file:expr) => {
        writeln!(
            $file,
            "fn vibe_execute_prompt(prompt: &str, meaning: Option<&str>, return_type: &str) -> VibeValue {{"
        )?;
        crate::generate_ollama_client_setup!($file);
        crate::generate_prompt_enhancement!($file);
        crate::generate_request_body!($file);
        crate::generate_parametric_ollama_request!($file);
        writeln!($file, "}}")?;
        writeln!($file)?;
    };
}

/// Generates the Ollama client setup code
#[macro_export]
macro_rules! generate_ollama_client_setup {
    ($file:expr) => {
        writeln!($file, "    let client = reqwest::blocking::Client::new();")?;
        writeln!(
            $file,
            "    let base_url = std::env::var(\"OLLAMA_BASE_URL\")"
        )?;
        writeln!(
            $file,
            "        .unwrap_or_else(|_| \"http://localhost:11223\".to_string());"
        )?;
        writeln!($file, "    let model = std::env::var(\"OLLAMA_MODEL\")")?;
        writeln!(
            $file,
            "        .unwrap_or_else(|_| \"llama3.2\".to_string());"
        )?;
        writeln!($file)?;
    };
}

/// Generates prompt enhancement logic for semantic meaning
#[macro_export]
macro_rules! generate_prompt_enhancement {
    ($file:expr) => {
        writeln!($file, "    let enhanced_prompt = match meaning {{")?;
        writeln!(
            $file,
            "        Some(m) => format!(\"Context: {{}}\\n\\nQuery: {{}}\", m, prompt),"
        )?;
        writeln!($file, "        None => prompt.to_string(),")?;
        writeln!($file, "    }};")?;
        writeln!($file)?;
    };
}

/// Generates the JSON request body for Ollama API
#[macro_export]
macro_rules! generate_request_body {
    ($file:expr) => {
        writeln!($file, "    let request_body = json!({{")?;
        writeln!($file, "        \"model\": model,")?;
        writeln!($file, "        \"prompt\": enhanced_prompt,")?;
        writeln!($file, "        \"stream\": false")?;
        writeln!($file, "    }});")?;
        writeln!($file)?;
    };
}

/// Generates parametric response parsing with semantic type handling
#[macro_export]
macro_rules! generate_parametric_response_handling {
    ($file:expr) => {
        writeln!($file, "        Ok(response) => {{")?;
        writeln!($file, "            if let Ok(response_json) = response.json::<serde_json::Value>() {{")?;
        writeln!($file, "                if let Some(content) = response_json.get(\"response\").and_then(|c| c.as_str()) {{")?;
        writeln!($file, "                    parse_semantic_response(content, meaning, return_type)")?;
        writeln!($file, "                }} else {{")?;
        writeln!($file, "                    VibeValue::String(\"Error: No response content\".to_string())")?;
        writeln!($file, "                }}")?;
        writeln!($file, "            }} else {{")?;
        writeln!($file, "                VibeValue::String(\"Error: Failed to parse JSON response\".to_string())")?;
        writeln!($file, "            }}")?;
        writeln!($file, "        }}")?;
    };
}

/// Generates error response handling
#[macro_export]
macro_rules! generate_error_response_handling {
    ($file:expr) => {
        writeln!($file, "        Err(e) => {{")?;
        writeln!($file, "            VibeValue::String(format!(\"Error: Failed to connect to Ollama: {{}}\", e))")?;
        writeln!($file, "        }}")?;
    };
}

/// Generates the parametric Ollama HTTP request and response handling
#[macro_export]
macro_rules! generate_parametric_ollama_request {
    ($file:expr) => {
        writeln!($file, "    match client")?;
        writeln!(
            $file,
            "        .post(&format!(\"{{}}/api/generate\", base_url))"
        )?;
        writeln!(
            $file,
            "        .header(\"Content-Type\", \"application/json\")"
        )?;
        writeln!($file, "        .json(&request_body)")?;
        writeln!(
            $file,
            "        .timeout(std::time::Duration::from_secs(30))"
        )?;
        writeln!($file, "        .send()")?;
        writeln!($file, "    {{")?;
        crate::generate_parametric_response_handling!($file);
        crate::generate_error_response_handling!($file);
        writeln!($file, "    }}")?;
    };
}

/// Generates the format_prompt utility function
#[macro_export]
macro_rules! generate_format_prompt_function {
    ($file:expr) => {
        writeln!(
            $file,
            "fn format_prompt(template: &str, variables: &HashMap<String, String>) -> String {{"
        )?;
        writeln!($file, "    let mut result = template.to_string();")?;
        writeln!($file, "    for (name, value) in variables {{")?;
        writeln!(
            $file,
            "        result = result.replace(&format!(\"{{}}\", name), value);"
        )?;
        writeln!($file, "    }}")?;
        writeln!($file, "    result")?;
        writeln!($file, "}}")?;
        writeln!($file)?;
    };
}

/// Generates all headers needed for a VibeLang generated file
#[macro_export]
macro_rules! generate_all_headers {
    ($file:expr) => {
        crate::generate_file_header!($file);
        crate::generate_imports!($file);
        crate::generate_parametric_vibe_execute_prompt!($file);
        crate::generate_semantic_parser!($file);
        crate::generate_extraction_utilities!($file);
        crate::generate_format_prompt_function!($file);
        crate::generate_vibe_value_enum!($file);
    };
}

