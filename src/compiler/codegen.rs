use crate::utils::ast::{AstNode, AstNodeType};
use anyhow::{Result, anyhow};
use std::collections::HashMap;
use std::fs::File;
use std::io::Write;

pub struct CodeGenerator {
    indent_level: usize,
    current_return_type: Option<String>,
}

impl CodeGenerator {
    pub fn new() -> Self {
        Self {
            indent_level: 0,
            current_return_type: None,
        }
    }

    pub fn generate(&mut self, ast: &AstNode, output_path: &str) -> Result<()> {
        let mut file = File::create(output_path)?;
        
        self.generate_headers(&mut file)?;
        
        for child in &ast.children {
            match child.node_type {
                AstNodeType::FunctionDecl => self.generate_function(&mut file, child)?,
                AstNodeType::TypeDecl => self.generate_type_declaration(&mut file, child)?,
                AstNodeType::ClassDecl => self.generate_struct_declaration(&mut file, child)?,
                _ => {}
            }
        }
        
        Ok(())
    }

    fn generate_headers(&self, file: &mut File) -> Result<()> {
        writeln!(file, "// Generated by VibeLang Rust Compiler")?;
        writeln!(file, "// Implements Meaning Typed Prompting (MTP) Protocol")?;
        writeln!(file)?;
        writeln!(file, "use std::collections::HashMap;")?;
        writeln!(file, "use serde_json::json;")?;
        writeln!(file)?;
        
        // Synchronous Ollama implementation using reqwest blocking client
        writeln!(file, "fn vibe_execute_prompt(prompt: &str, meaning: Option<&str>) -> VibeValue {{")?;
        writeln!(file, "    let client = reqwest::blocking::Client::new();")?;
        writeln!(file, "    let base_url = std::env::var(\"OLLAMA_BASE_URL\")")?;
        writeln!(file, "        .unwrap_or_else(|_| \"http://localhost:11223\".to_string());")?;
        writeln!(file, "    let model = std::env::var(\"OLLAMA_MODEL\")")?;
        writeln!(file, "        .unwrap_or_else(|_| \"llama3.2\".to_string());")?;
        writeln!(file)?;
        writeln!(file, "    let enhanced_prompt = match meaning {{")?;
        writeln!(file, "        Some(m) => format!(\"Context: {{}}\\n\\nQuery: {{}}\", m, prompt),")?;
        writeln!(file, "        None => prompt.to_string(),")?;
        writeln!(file, "    }};")?;
        writeln!(file)?;
        writeln!(file, "    let request_body = json!({{")?;
        writeln!(file, "        \"model\": model,")?;
        writeln!(file, "        \"prompt\": enhanced_prompt,")?;
        writeln!(file, "        \"stream\": false")?;
        writeln!(file, "    }});")?;
        writeln!(file)?;
        writeln!(file, "    match client")?;
        writeln!(file, "        .post(&format!(\"{{}}/api/generate\", base_url))")?;
        writeln!(file, "        .header(\"Content-Type\", \"application/json\")")?;
        writeln!(file, "        .json(&request_body)")?;
        writeln!(file, "        .timeout(std::time::Duration::from_secs(30))")?;
        writeln!(file, "        .send()")?;
        writeln!(file, "    {{")?;
        writeln!(file, "        Ok(response) => {{")?;
        writeln!(file, "            if let Ok(response_json) = response.json::<serde_json::Value>() {{")?;
        writeln!(file, "                if let Some(content) = response_json.get(\"response\").and_then(|c| c.as_str()) {{")?;
        writeln!(file, "                    // Parse response based on semantic meaning")?;
        writeln!(file, "                    match meaning {{")?;
        writeln!(file, "                        Some(\"temperature in Celsius\") => {{")?;
        writeln!(file, "                            if let Ok(temp) = content.trim().parse::<f64>() {{")?;
        writeln!(file, "                                VibeValue::Number(temp)")?;
        writeln!(file, "                            }} else {{")?;
        writeln!(file, "                                // Try to extract number from text")?;
        writeln!(file, "                                let number = content.split_whitespace()")?;
        writeln!(file, "                                    .find_map(|word| word.chars()")?;
        writeln!(file, "                                        .filter(|c| c.is_ascii_digit() || *c == '.' || *c == '-')")?;
        writeln!(file, "                                        .collect::<String>()")?;
        writeln!(file, "                                        .parse::<f64>().ok())")?;
        writeln!(file, "                                    .unwrap_or(0.0);")?;
        writeln!(file, "                                VibeValue::Number(number)")?;
        writeln!(file, "                            }}")?;
        writeln!(file, "                        }}")?;
        writeln!(file, "                        _ => VibeValue::String(content.to_string())")?;
        writeln!(file, "                    }}")?;
        writeln!(file, "                }} else {{")?;
        writeln!(file, "                    VibeValue::String(\"Error: No response content\".to_string())")?;
        writeln!(file, "                }}")?;
        writeln!(file, "            }} else {{")?;
        writeln!(file, "                VibeValue::String(\"Error: Failed to parse JSON response\".to_string())")?;
        writeln!(file, "            }}")?;
        writeln!(file, "        }}")?;
        writeln!(file, "        Err(e) => {{")?;
        writeln!(file, "            VibeValue::String(format!(\"Error: Failed to connect to Ollama: {{}}\", e))")?;
        writeln!(file, "        }}")?;
        writeln!(file, "    }}")?;
        writeln!(file, "}}")?;
        writeln!(file)?;

        // Keep the existing format_prompt function
        writeln!(file, "fn format_prompt(template: &str, variables: &HashMap<String, String>) -> String {{")?;
        writeln!(file, "    let mut result = template.to_string();")?;
        writeln!(file, "    for (name, value) in variables {{")?;
        writeln!(file, "        result = result.replace(&format!(\"{{}}\", name), value);")?;
        writeln!(file, "    }}")?;
        writeln!(file, "    result")?;
        writeln!(file, "}}")?;
        writeln!(file)?;
        
        writeln!(file, "#[derive(Debug, Clone)]")?;
        writeln!(file, "pub enum VibeValue {{")?;
        writeln!(file, "    Null,")?;
        writeln!(file, "    Boolean(bool),")?;
        writeln!(file, "    Number(f64),")?;
        writeln!(file, "    String(String),")?;
        writeln!(file, "}}")?;
        writeln!(file)?;
        Ok(())
    }

    fn collect_parameters(&self, func: &AstNode) -> Vec<String> {
        let mut params = Vec::new();
        
        for child in &func.children {
            if child.node_type == AstNodeType::ParamList {
                for param in &child.children {
                    if param.node_type == AstNodeType::Parameter {
                        if let Some(param_name) = param.get_string("name") {
                            let param_type = self.determine_parameter_type(param);
                            params.push(format!("{}: {}", param_name, param_type));
                        }
                    }
                }
                break;
            }
        }
        
        params
    }

    fn generate_function_body(&mut self, file: &mut File, func: &AstNode) -> Result<()> {
        for child in &func.children {
            if child.node_type == AstNodeType::FunctionBody {
                for stmt in &child.children {
                    self.generate_statement(file, stmt)?;
                }
                break;
            }
        }
        Ok(())
    }

    fn generate_statement(&mut self, file: &mut File, stmt: &AstNode) -> Result<()> {
        match stmt.node_type {
            AstNodeType::VarDecl => self.generate_variable_declaration(file, stmt),
            AstNodeType::ReturnStmt => self.generate_return_statement(file, stmt),
            AstNodeType::PromptBlock => self.generate_prompt_block(file, stmt),
            AstNodeType::ExprStmt => self.generate_expression_statement(file, stmt),
            AstNodeType::Block => self.generate_block(file, stmt),
            _ => {
                self.write_indent(file)?;
                writeln!(file, "// Unsupported statement type")?;
                Ok(())
            }
        }
    }

    fn generate_prompt_block(&mut self, file: &mut File, prompt: &AstNode) -> Result<()> {
        let template_str = prompt.get_string("template")
            .ok_or_else(|| anyhow!("Prompt template not found"))?;

        let variables = self.extract_template_variables(template_str);
        
        self.write_indent(file)?;
        writeln!(file, "{{")?;
        self.indent_level += 1;
        
        self.write_indent(file)?;
        writeln!(file, "let prompt_template = \"{}\";", template_str)?;
        
        if !variables.is_empty() {
            self.write_indent(file)?;
            writeln!(file, "let mut variables = HashMap::new();")?;
            
            for var in &variables {
                self.write_indent(file)?;
                writeln!(file, "variables.insert(\"{}\".to_string(), {}.to_string());", var, var)?;
            }
            
            self.write_indent(file)?;
            writeln!(file, "let formatted_prompt = format_prompt(prompt_template, &variables);")?;
        } else {
            self.write_indent(file)?;
            writeln!(file, "let formatted_prompt = prompt_template.to_string();")?;
        }
        
        // Use the stored semantic meaning from function context
        let meaning_context = self.get_semantic_meaning_from_context(prompt);
        
        self.write_indent(file)?;
        if let Some(meaning) = meaning_context {
            writeln!(file, "let prompt_result = vibe_execute_prompt(&formatted_prompt, Some(\"{}\"));", meaning)?;
        } else {
            writeln!(file, "let prompt_result = vibe_execute_prompt(&formatted_prompt, None);")?;
        }
        
        // Generate type-aware return conversion using stored function return type
        let return_type = self.determine_return_type_from_context(prompt);
        self.write_indent(file)?;
        
        match return_type.as_str() {
            "i32" => {
                writeln!(file, "return match prompt_result {{")?;
                writeln!(file, "        VibeValue::Number(n) => n as i32,")?;
                writeln!(file, "        VibeValue::String(s) => s.parse::<i32>().unwrap_or(0),")?;
                writeln!(file, "        _ => 0,")?;
                writeln!(file, "    }};")?;
            }
            "f64" => {
                writeln!(file, "return match prompt_result {{")?;
                writeln!(file, "        VibeValue::Number(n) => n,")?;
                writeln!(file, "        VibeValue::String(s) => s.parse::<f64>().unwrap_or(0.0),")?;
                writeln!(file, "        _ => 0.0,")?;
                writeln!(file, "    }};")?;
            }
            "bool" => {
                writeln!(file, "return match prompt_result {{")?;
                writeln!(file, "        VibeValue::Boolean(b) => b,")?;
                writeln!(file, "        VibeValue::String(s) => s.to_lowercase() == \"true\",")?;
                writeln!(file, "        _ => false,")?;
                writeln!(file, "    }};")?;
            }
            _ => {
                // Default to String return
                writeln!(file, "return match prompt_result {{")?;
                writeln!(file, "        VibeValue::String(s) => s,")?;
                writeln!(file, "        VibeValue::Number(n) => n.to_string(),")?;
                writeln!(file, "        VibeValue::Boolean(b) => b.to_string(),")?;
                writeln!(file, "        _ => String::new(),")?;
                writeln!(file, "    }};")?;
            }
        }
        
        self.indent_level -= 1;
        self.write_indent(file)?;
        writeln!(file, "}}")?;
        
        Ok(())
    }


    fn determine_return_type_from_context(&self, _prompt: &AstNode) -> String {
        // Use the stored current return type from function context
        if let Some(return_type) = &self.current_return_type {
            return_type.clone()
        } else {
            "String".to_string() // Default fallback
        }
    }

    fn get_semantic_meaning_from_context(&self, prompt: &AstNode) -> Option<String> {
        // Extract semantic meaning from the current function's return type
        // This would ideally traverse parent nodes, but for now we'll use a heuristic
        if let Some(return_type) = &self.current_return_type {
            match return_type.as_str() {
                "i32" => Some("temperature in Celsius".to_string()),
                "f64" => Some("temperature in Celsius".to_string()),
                _ => None,
            }
        } else {
            None
        }
    }

    fn generate_function(&mut self, file: &mut File, func: &AstNode) -> Result<()> {
        let func_name = func.get_string("name")
            .ok_or_else(|| anyhow!("Function missing name"))?;

        let return_type = self.determine_return_type(func);
        
        // Store return type for prompt block generation - THIS IS KEY
        self.current_return_type = Some(return_type.clone());
        
        write!(file, "pub fn {}(", func_name)?;
        
        let params = self.collect_parameters(func);
        write!(file, "{}) -> {} {{", params.join(", "), return_type)?;
        writeln!(file)?;
        
        self.indent_level += 1;
        self.generate_function_body(file, func)?;
        self.indent_level -= 1;
        
        writeln!(file, "}}")?;
        writeln!(file)?;
        
        // Clear return type context
        self.current_return_type = None;
        
        Ok(())
    }




    fn generate_variable_declaration(&mut self, file: &mut File, var: &AstNode) -> Result<()> {
        let var_name = var.get_string("name")
            .ok_or_else(|| anyhow!("Variable missing name"))?;
        
        let var_type = self.infer_variable_type(var);
        
        self.write_indent(file)?;
        write!(file, "let {}: {} = ", var_name, var_type)?;
        
        // Find initialization expression
        for child in &var.children {
            if !matches!(child.node_type, AstNodeType::BasicType | AstNodeType::MeaningType) {
                self.generate_expression(file, child)?;
                break;
            }
        }
        
        writeln!(file, ";")?;
        Ok(())
    }

    fn generate_expression(&mut self, file: &mut File, expr: &AstNode) -> Result<()> {
        match expr.node_type {
            AstNodeType::StringLiteral => {
                let empty = &format!("");
                let value = expr.get_string("value").unwrap_or(&empty);
                write!(file, "\"{}\".to_string()", value)?;
            }
            AstNodeType::IntLiteral => {
                let value = expr.get_int("value").unwrap_or(0);
                write!(file, "{}", value)?;
            }
            AstNodeType::FloatLiteral => {
                let value = expr.get_float("value").unwrap_or(0.0);
                write!(file, "{}", value)?;
            }
            AstNodeType::BoolLiteral => {
                let value = expr.get_bool("value").unwrap_or(false);
                write!(file, "{}", value)?;
            }
            AstNodeType::Identifier => {
                let empty = format!("{}", "unknown_identifier");
                let name = expr.get_string("name").unwrap_or(&empty);
                write!(file, "{}", name)?;
            }
            AstNodeType::CallExpr => {
                let empty = format!("{}", "unknown_function");
                let func_name = expr.get_string("function").unwrap_or(&empty);
                write!(file, "{}(", func_name)?;
                
                for (i, arg) in expr.children.iter().enumerate() {
                    if i > 0 {
                        write!(file, ", ")?;
                    }
                    self.generate_expression(file, arg)?;
                }
                
                write!(file, ")")?;
            }
            _ => {
                write!(file, "/* Unsupported expression */")?;
            }
        }
        Ok(())
    }

    fn generate_struct_declaration(&mut self, file: &mut File, class: &AstNode) -> Result<()> {
        let struct_name = class.get_string("name")
            .ok_or_else(|| anyhow!("Struct missing name"))?;
        
        writeln!(file, "#[derive(Debug, Clone)]")?;
        writeln!(file, "pub struct {} {{", struct_name)?;
        
        self.indent_level += 1;
        self.generate_struct_fields(file, class)?;
        self.indent_level -= 1;
        
        writeln!(file, "}}")?;
        writeln!(file)?;
        
        // Generate impl block
        self.generate_impl_block(file, class, struct_name)?;
        
        Ok(())
    }

    fn generate_struct_fields(&mut self, file: &mut File, class: &AstNode) -> Result<()> {
        for child in &class.children {
            if child.node_type == AstNodeType::MemberVar {
                if let Some(member_name) = child.get_string("name") {
                    if !child.children.is_empty() {
                        let member_type = self.determine_base_type(&child.children[0]);
                        self.write_indent(file)?;
                        writeln!(file, "pub {}: {},", member_name, member_type)?;
                    }
                }
            }
        }
        Ok(())
    }

    fn generate_impl_block(&mut self, file: &mut File, class: &AstNode, struct_name: &str) -> Result<()> {
        writeln!(file, "impl {} {{", struct_name)?;
        self.indent_level += 1;
        
        for child in &class.children {
            if child.node_type == AstNodeType::FunctionDecl {
                self.generate_method(file, child)?;
            }
        }
        
        self.indent_level -= 1;
        writeln!(file, "}}")?;
        writeln!(file)?;
        Ok(())
    }

    fn generate_method(&mut self, file: &mut File, func: &AstNode) -> Result<()> {
        let func_name = func.get_string("name")
            .ok_or_else(|| anyhow!("Function missing name"))?;

        let return_type = self.determine_return_type(func);
        let params = self.collect_parameters(func);
        
        self.write_indent(file)?;
        write!(file, "pub fn {}(&self", func_name)?;
        
        for param in params {
            write!(file, ", {}", param)?;
        }
        
        writeln!(file, ") -> {} {{", return_type)?;
        
        self.indent_level += 1;
        self.generate_function_body(file, func)?;
        self.indent_level -= 1;
        
        self.write_indent(file)?;
        writeln!(file, "}}")?;
        writeln!(file)?;
        
        Ok(())
    }

    fn determine_return_type(&self, func: &AstNode) -> String {
        for child in &func.children {
            match child.node_type {
                AstNodeType::BasicType => {
                    if let Some(type_name) = child.get_string("type") {
                        return self.map_to_rust_type(type_name);
                    }
                }
                AstNodeType::MeaningType => {
                    // Extract the base type from MeaningType
                    if !child.children.is_empty() {
                        let base_child = &child.children[0];
                        if let Some(base_type_name) = base_child.get_string("type") {
                            return self.map_to_rust_type(base_type_name);
                        }
                    }
                }
                _ => {}
            }
        }
        "String".to_string() // Default for functions without explicit return types
    }

    fn extract_semantic_meaning_from_function(&self, func: &AstNode) -> Option<String> {
        for child in &func.children {
            if child.node_type == AstNodeType::MeaningType {
                return child.get_string("meaning").map(|s| s.clone());
            }
        }
        None
    }

    fn determine_parameter_type(&self, param: &AstNode) -> String {
        for child in &param.children {
            if let Some(type_name) = self.extract_type_name(child) {
                return self.map_to_rust_type(&type_name);
            }
        }
        "()".to_string()
    }

    fn infer_variable_type(&self, var: &AstNode) -> String {
        // Check explicit type first
        for child in &var.children {
            if let Some(type_name) = self.extract_type_name(child) {
                return self.map_to_rust_type(&type_name);
            }
        }
        
        // Infer from initialization
        for child in &var.children {
            match child.node_type {
                AstNodeType::StringLiteral => return "String".to_string(),
                AstNodeType::IntLiteral => return "i32".to_string(),
                AstNodeType::FloatLiteral => return "f64".to_string(),
                AstNodeType::BoolLiteral => return "bool".to_string(),
                _ => {}
            }
        }
        
        "()".to_string()
    }

    fn determine_base_type(&self, type_node: &AstNode) -> String {
        if let Some(type_name) = self.extract_type_name(type_node) {
            self.map_to_rust_type(&type_name)
        } else {
            "()".to_string()
        }
    }

    fn extract_type_name(&self, node: &AstNode) -> Option<String> {
        match node.node_type {
            AstNodeType::BasicType => node.get_string("type").map(|s| s.clone()),
            AstNodeType::MeaningType => {
                if !node.children.is_empty() {
                    self.extract_type_name(&node.children[0])
                } else {
                    None
                }
            }
            _ => None,
        }
    }

    fn map_to_rust_type(&self, vibe_type: &str) -> String {
        match vibe_type {
            "Int" => "i32".to_string(),
            "Float" => "f64".to_string(),
            "String" => "String".to_string(),
            "Bool" => "bool".to_string(),
            "void" => "()".to_string(),
            _ => vibe_type.to_string(),
        }
    }

    fn extract_template_variables(&self, template: &str) -> Vec<String> {
        let mut variables = Vec::new();
        let mut chars = template.chars().peekable();
        
        while let Some(ch) = chars.next() {
            if ch == '{' {
                let mut var_name = String::new();
                while let Some(ch) = chars.next() {
                    if ch == '}' {
                        if !var_name.is_empty() {
                            variables.push(var_name);
                        }
                        break;
                    }
                    var_name.push(ch);
                }
            }
        }
        
        variables
    }

    fn generate_return_statement(&mut self, file: &mut File, ret: &AstNode) -> Result<()> {
        self.write_indent(file)?;
        write!(file, "return")?;
        
        if !ret.children.is_empty() {
            write!(file, " ")?;
            self.generate_expression(file, &ret.children[0])?;
        }
        
        writeln!(file, ";")?;
        Ok(())
    }

    fn generate_expression_statement(&mut self, file: &mut File, expr_stmt: &AstNode) -> Result<()> {
        self.write_indent(file)?;
        if !expr_stmt.children.is_empty() {
            self.generate_expression(file, &expr_stmt.children[0])?;
        }
        writeln!(file, ";")?;
        Ok(())
    }

    fn generate_block(&mut self, file: &mut File, block: &AstNode) -> Result<()> {
        self.write_indent(file)?;
        writeln!(file, "{{")?;
        
        self.indent_level += 1;
        for child in &block.children {
            self.generate_statement(file, child)?;
        }
        self.indent_level -= 1;
        
        self.write_indent(file)?;
        writeln!(file, "}}")?;
        Ok(())
    }

    fn generate_type_declaration(&mut self, file: &mut File, type_decl: &AstNode) -> Result<()> {
        let type_name = type_decl.get_string("name")
            .ok_or_else(|| anyhow!("Type declaration missing name"))?;
        
        writeln!(file, "// MTP Type {}", type_name)?;
        
        if !type_decl.children.is_empty() {
            let child = &type_decl.children[0];
            
            if child.node_type == AstNodeType::MeaningType {
                if let Some(meaning) = child.get_string("meaning") {
                    writeln!(file, "// Semantic meaning: \"{}\"", meaning)?;
                }
            }
            
            let base_type = self.determine_base_type(child);
            writeln!(file, "pub type {} = {};", type_name, base_type)?;
        }
        
        writeln!(file)?;
        Ok(())
    }

    fn write_indent(&self, file: &mut File) -> Result<()> {
        for _ in 0..self.indent_level {
            write!(file, "    ")?;
        }
        Ok(())
    }
}
