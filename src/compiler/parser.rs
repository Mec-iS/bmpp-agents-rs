use crate::utils::ast::{AstNode, AstNodeType};
use anyhow::{anyhow, Result};
use pest::iterators::Pair;
use pest::Parser;

#[derive(pest_derive::Parser)]
#[grammar = "src/vibelang.pest"] 
pub struct VibeParser;

pub fn parse_source(source: &str) -> Result<AstNode> {
    // Now that the macro can find the file, `VibeParser::parse` will exist.
    let pairs = VibeParser::parse(Rule::Program, source)?
        .next()
        .ok_or_else(|| anyhow!("Failed to parse program: no pairs found"))?;

    let mut program_node = AstNode::new(AstNodeType::Program);
    // The `Rule` enum is now successfully generated by the derive macro.
    for pair in pairs.into_inner() {
        if let Rule::Declaration = pair.as_rule() {
             if let Some(declaration) = pair.into_inner().next() {
                let decl_node = build_ast_from_pair(declaration)?;
                program_node.add_child(decl_node);
             }
        }
    }
    Ok(program_node)
}

fn build_ast_from_pair(pair: Pair<Rule>) -> Result<AstNode> {
    match pair.as_rule() {
        Rule::FunctionDecl => {
            let mut inner = pair.into_inner();
            let name = inner.next().unwrap().as_str();
            let mut func = AstNode::new(AstNodeType::FunctionDecl);
            func.set_string("name", name);

            for item in inner {
                match item.as_rule() {
                    Rule::ParamList => {
                        let mut params_node = AstNode::new(AstNodeType::ParamList);
                        for param_pair in item.into_inner() {
                             let mut param_inner = param_pair.into_inner();
                             let param_name = param_inner.next().unwrap().as_str();
                             let param_type = build_ast_from_pair(param_inner.next().unwrap())?;
                             let mut param_node = AstNode::new(AstNodeType::Parameter);
                             param_node.set_string("name", param_name);
                             param_node.add_child(param_type);
                             params_node.add_child(param_node);
                        }
                        func.add_child(params_node);
                    },
                    Rule::Type => {
                        let type_node = build_ast_from_pair(item)?;
                        func.add_child(type_node);
                    }
                    Rule::Block => {
                         let body = build_ast_from_pair(item)?;
                         func.add_child(body);
                    }
                    _ => {}
                }
            }
            Ok(func)
        }
        Rule::Block => {
            let mut block_node = AstNode::new(AstNodeType::Block);
            for stmt_pair in pair.into_inner() {
                 if let Rule::Statement = stmt_pair.as_rule() {
                     if let Some(statement) = stmt_pair.into_inner().next() {
                         let stmt_node = build_ast_from_pair(statement)?;
                         block_node.add_child(stmt_node);
                     }
                 }
            }
            Ok(block_node)
        }
        Rule::PromptStmt => {
            let template = pair.into_inner().next().unwrap().as_str();
            let mut prompt_node = AstNode::new(AstNodeType::PromptBlock);
            // Remove quotes from the string literal
            prompt_node.set_string("template", &template[1..template.len() - 1]);
            Ok(prompt_node)
        }
        Rule::TypeDecl => {
            let mut inner = pair.into_inner();
            let name = inner.next().unwrap().as_str();
            let type_def = build_ast_from_pair(inner.next().unwrap())?;

            let mut type_decl_node = AstNode::new(AstNodeType::TypeDecl);
            type_decl_node.set_string("name", name);
            type_decl_node.add_child(type_def);
            Ok(type_decl_node)
        }
        Rule::Type => {
            // Recurse into the actual type rule (MeaningType or BasicType)
            build_ast_from_pair(pair.into_inner().next().unwrap())
        }
        Rule::MeaningType => {
            let mut inner = pair.into_inner();
            let base_type = build_ast_from_pair(inner.next().unwrap())?;
            let meaning_str = inner.next().unwrap().as_str();

            let mut meaning_node = AstNode::new(AstNodeType::MeaningType);
            // Remove quotes from the string literal
            meaning_node.set_string("meaning", &meaning_str[1..meaning_str.len() - 1]);
            meaning_node.add_child(base_type);
            Ok(meaning_node)
        }
        Rule::BasicType => {
            let type_name = pair.as_str();
            let mut basic_type_node = AstNode::new(AstNodeType::BasicType);
            basic_type_node.set_string("type", type_name);
            Ok(basic_type_node)
        }
        _ => Err(anyhow!("Unhandled grammar rule: {:?}", pair.as_rule())),
    }
}
