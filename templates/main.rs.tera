// Generated by VibeLang-rs Compiler
// MIT License
// Copyright (c) 2025 Mec-iS
// This file is generated from a template. Do not edit manually.

use vibelang::runtime::llm_provider::LlmProvider;
use vibelang::runtime::{
    client::LlmClient,
    types::VibeValue,
};
use vibelang::runtime::llm_provider::LlmProvider;

// --- MTP Type Definitions ---
{% for alias in type_aliases %}
// Semantic meaning: "{{ alias.meaning | default(value="none") }}"
pub type {{ alias.name }} = {{ alias.base_type }};
{% endfor %}

// --- Semantic Extraction Utilities ---

fn extract_generic_number(text: &str) -> i32 {
    text.split_whitespace()
        .find_map(|word| word.parse::<i32>().ok())
        .unwrap_or(0)
}

fn extract_generic_float(text: &str) -> f64 {
    text.split_whitespace()
        .find_map(|word| word.parse::<f64>().ok())
        .unwrap_or(0.0)
}

{% for group in semantic_type_groups %}
{% for handler in group.handlers %}
fn extract_{{ handler.normalized_name }}_value(text: &str) -> {{ group.rust_type }} {
    {% if group.rust_type == "i32" %}
    extract_generic_number(text)
    {% elif group.rust_type == "f64" %}
    extract_generic_float(text)
    {% else %}
    text.trim().to_string()
    {% endif %}
}
{% endfor %}
{% endfor %}

// --- Semantic Parser Dispatch ---
fn parse_semantic_response(content: &str, meaning: Option<&str>, return_type: &str) -> VibeValue {
    match return_type {
        "i32" => {
            let value = match meaning {
                {% for group in semantic_type_groups %}{% if group.rust_type == "i32" %}{% for handler in group.handlers %}
                Some("{{ handler.meaning }}") => extract_{{ handler.normalized_name }}_value(content),{% endfor %}{% endif %}{% endfor %}
                _ => extract_generic_number(content),
            };
            VibeValue::Number(value as f64)
        }
        "f64" => {
            let value = match meaning {
                {% for group in semantic_type_groups %}{% if group.rust_type == "f64" %}{% for handler in group.handlers %}
                Some("{{ handler.meaning }}") => extract_{{ handler.normalized_name }}_value(content),{% endfor %}{% endif %}{% endfor %}
                _ => extract_generic_float(content),
            };
            VibeValue::Number(value)
        }
        "bool" => {
            let b = content.trim().to_lowercase();
            VibeValue::Boolean(b == "true" || b == "yes" || b == "1")
        }
        _ => { // Default to String
            let value = match meaning {
                 {% for group in semantic_type_groups %}{% if group.rust_type == "String" %}{% for handler in group.handlers %}
                Some("{{ handler.meaning }}") => extract_{{ handler.normalized_name }}_value(content),{% endfor %}{% endif %}{% endfor %}
                _ => content.trim().to_string(),
            };
            VibeValue::String(value)
        }
    }
}

// --- Core Runtime Execution ---
fn vibe_execute_prompt(llm: &LlmClient, prompt: &str, meaning: Option<&str>, return_type: &str) -> VibeValue {
    let enhanced_prompt = match meaning {
        Some(m) => format!("Context: You are an AI assistant that must perform a specific task. The user wants a value that has the semantic meaning of \"{}\". Please provide a concise answer based on the following query.\n\nQuery: {}", m, prompt),
        None => prompt.to_string(),
    };

    match llm.generate(&enhanced_prompt) {
        Ok(response) => parse_semantic_response(&response, meaning, return_type),
        Err(e) => {
            eprintln!("LLM execution failed: {}", e);
            VibeValue::Null
        }
    }
}

// --- Generated VibeLang Functions ---
{% for func in functions %}
pub fn {{ func.name }}(llm: &LlmClient, {% for param in func.params %}{{ param.name }}: {{ param.rust_type }}{% if not loop.last %}, {% endif %}{% endfor %}) -> {{ func.return_type }} {
    let mut template = "{{ func.prompt_template }}".to_string();
    {% for param in func.params %}
    template = template.replace("{ {{- param.name -}} }", &{{ param.name }}.to_string());
    {% endfor %}
    
    let meaning = {% if func.semantic_meaning %}Some("{{ func.semantic_meaning }}"){% else %}None{% endif %};
    // CHANGE: The string passed to the runtime is the base type, not the alias.
    let return_type_str = "{{ func.return_base_type }}";

    let result = vibe_execute_prompt(llm, &template, meaning, return_type_str);

    // CHANGE: The logic now uses `func.return_base_type` to generate the correct conversion call.
    {% if func.return_base_type == "i32" %}
    result.into_i32()
    {% elif func.return_base_type == "f64" %}
    result.into_f64()
    {% elif func.return_base_type == "bool" %}
    result.into_bool()
    {% else %} // Assumes String or a type aliased to String
    result.into_string()
    {% endif %}
}
{% endfor %}

// --- Main application entry point ---
fn main() {
    println!("VibeLang program compiled: Check there is a local Ollama instance running");
    println!("VibeLang program compiled: To run the functions, uncomment the code below.");

    /*
    // 1. Set up the LLM Client
    // This reads OLLAMA_BASE_URL and OLLAMA_MODEL from your environment variables.
    println!("Setting up LLM client...");
    let config = vibelang::config::Config::from_env();
    let client = vibelang::runtime::client::LlmClient::new(config)
        .expect("Failed to create LLM client");

    // 2. Call a generated function
    println!("\n--- Querying LLM ---");
    let country = "Japan".to_string();
    let capital = get_capital(&client, country);
    println!("The capital of Japan is: {}", capital);

    let population = get_population(&client, "Brazil".to_string());
    println!("The population of Brazil is roughly {} million.", population);

    let fact = get_historical_fact(&client, "Cleopatra".to_string());
    println!("A fact about Cleopatra: {}", fact);
    */
}
